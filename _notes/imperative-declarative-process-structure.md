---
title: Dichotomy between process and structure
tags: software
---

### [Hibai](https://t.me/nature_of_order_chat/473)
Aren’t you, in declarative, not applying a series of transformations to a whole and you get a different whole as a result?

### [Stefan](https://t.me/nature_of_order_chat/474)
I meant imperative and declarative as in describing the process of how something comes about vs. describing the properties a result must have. 

That is somewhat behind the idea of imperative vs. declarative programming languages too, but I think "declarative style" in programming has been watered down to "declaring the algorithm I intend to use" over implementing it directly in the language's lowest level constructs. For example, when people consider using a map() operation over a for-loop as "more declarative" (which it certainly is). Of course, that's still in the end just a transformation, described in a slightly different way.

### [Prabros](https://t.me/nature_of_order_chat/484)
> This is at the core of Alexander's theory, who talks at length about both structure (Book 1) and process (Book 2) and provides a lot of the reasoning for why the slightly less obvious approach of breaking complexity down in process as opposed to structure is more powerful in the sense that we can create more complex systems that way.

**Would you be able to compare this process vs. structure as one about tradeoff between time vs. space?**

### [Prabros](https://t.me/nature_of_order_chat/486)
* <https://www.ontology.co/two-views-language.htm>
* debate between **logic as language and logic as calculus**. That distinction had deep links between how we arrived at grammar mood oriented **declarative / imperative styles**
* It is not an XOR position, but could well be an inclusive OR, but I think casting it in that manner has created this (false?) shadow of schism between imperative and declarative languages.

### [Prabros](https://t.me/nature_of_order_chat/487)
> What we end up doing instead though, is we use an order that feels natural to us — from lowest to highest. We could still use a lookup table, but now we have much more efficient ways of converting a sequence of binary values into a natural number (and back): We can use an algorithm. That is more efficient, and it seems more elegant to do it that way. There are many different possible orders we can choose, but this one appeals to us a lot, because it somehow makes more sense. 

I guess this hints at what you meant by compressing it by a process instead of structure earlier. Would I be off the point if I read this as: **You compactify a space that can be unfolded in time as a set of rules. Now, you can unfold and recreate the structures via the procedural rules at will?**

---

## References
- [ ] https://www.ontology.co/two-views-language.htm
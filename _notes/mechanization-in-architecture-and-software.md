---
title: Mechanization in architecture and software
---

> Big buildings perhaps pose the biggest problem for a way of building that can produce living structure. During the 20th century these big processes were **mechanized** in such a way as to **disrupt the unfolding process** almost completely.
> As a result, in such projects especially, living structure was almost unattainable in the 20th century. Yet it is our age, the 20th century and beyond, which has **given birth to these enormous building projects**, and our time which therefore most **urgently needs ways of building them well**.
> 
> — Christopher Alexander, The Nature of Order, Book 3: A Vision of a Living World, chapter 4: Large Public Buildings, section 9: The Contracting Problem, p. 125

Technological progress enabled us to pursue ideas larger in scale: build bigger buildings, create more complex software. However, the only way we knew how to make this work, was by focusing on mechanical process efficiency and avoid complexity through mass production. 

In architecture, we found more efficient ways to work with materials and mass produce components faster, in higher volumes, and cheaper through mechanizing the manufacturing process with machines and automation, reducing manual labor and required competence [-> Frederik Taylor, Taylorism, Book 2, Part 3].

In software, where mass production boils down to simple copying, the effects were even more pronounced. As the duplication of digital information is possible without any cost (or negligible marginal cost for electricity and data storage), thinking in independent and reusable components became paramount.

As a result, both industries embraced modularization as the primary — and perhaps only — way of managing the complexity that comes with larger projects.

Components are designed independently from the context in which they will be used in. Untangling the network of relationships between components and “avoiding coupling” became one of the important mantras for building complex software.

The isolated production of exact clones of components or reuse of the exact same components in software, does solve the issue of complexity to a certain extent. It also brings tremendous benefits in reduction of cost. At the same time it prevents any valuable adaptation to happen, which is the essence of the fundamental process and required for life to occur in the finished product.